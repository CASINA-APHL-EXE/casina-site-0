<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CASINA // FACTORY ONLINE</title>

  <style>
    :root{ --cyan: 0,255,255; }
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }

    /* Particle canvas (background) */
    #c {
      position: fixed; inset: 0;
      width: 100vw; height: 100vh;
      display:block;
      z-index: 0;
    }

    /* 3D canvas (head) */
    #three {
      position: fixed; inset: 0;
      width: 100vw; height: 100vh;
      display:block;
      z-index: 1;
      pointer-events: none;
    }

    /* HUD text */
    .hud{
      position: fixed; left: 18px; top: 16px;
      color: rgba(var(--cyan),0.85);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      letter-spacing: .12em;
      text-transform: uppercase;
      user-select: none;
      pointer-events: none;
      mix-blend-mode: screen;
      z-index: 2;
    }
    .hud .title{ font-size: 14px; opacity: 0.95; }
    .hud .sub{ margin-top: 6px; font-size: 11px; opacity: 0.6; }

    /* Optional: small vignette to make center pop */
    .vignette{
      position: fixed; inset: 0;
      pointer-events: none;
      z-index: 2;
      background: radial-gradient(circle at 50% 55%, rgba(0,0,0,0) 0%, rgba(0,0,0,0.35) 60%, rgba(0,0,0,0.7) 100%);
      mix-blend-mode: multiply;
    }
  </style>
</head>

<body>
  <!-- Background particles -->
  <canvas id="c"></canvas>

  <!-- 3D head overlay -->
  <canvas id="three"></canvas>

  <div class="hud" aria-hidden="true">
    <div class="title">XERLEVATE // FACTORY ONLINE</div>
    <div class="sub">cyan field · idle drift / cursor cohesion</div>
  </div>
  <div class="vignette" aria-hidden="true"></div>

  <!-- ===================== -->
  <!-- Particles (your code) -->
  <!-- ===================== -->
  <script>
  (() => {
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha: false });

    // -------- Retina-safe resize --------
    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width  = Math.floor(innerWidth  * dpr);
      canvas.height = Math.floor(innerHeight * dpr);
      canvas.style.width = innerWidth + "px";
      canvas.style.height = innerHeight + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    addEventListener("resize", resize);
    resize();

    // -------- Mouse state --------
    const mouse = { x: innerWidth/2, y: innerHeight/2, lastMove: 0 };
    const now = () => performance.now();

    function touchMouse(x,y){
      mouse.x = x; mouse.y = y;
      mouse.lastMove = now();
    }
    addEventListener("pointermove", (e)=> touchMouse(e.clientX, e.clientY));
    addEventListener("pointerdown", (e)=> touchMouse(e.clientX, e.clientY));

    // -------- Particles --------
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const rand = (a,b)=>a+Math.random()*(b-a);

    let COUNT = 220;
    function recomputeCount(){
      COUNT = Math.min(260, Math.max(120, Math.floor((innerWidth*innerHeight)/6500)));
    }
    recomputeCount();
    addEventListener("resize", recomputeCount);

    const particles = [];
    function seed() {
      particles.length = 0;
      for (let i=0; i<COUNT; i++) {
        particles.push({
          x: rand(0, innerWidth),
          y: rand(0, innerHeight),
          vx: rand(-0.35, 0.35),
          vy: rand(-0.35, 0.35),
          r: rand(1.2, 2.6),
          phase: rand(0, Math.PI*2),
        });
      }
    }
    seed();

    // -------- Render loop --------
    function frame(t){
      // activity strength: move -> 1, idle -> 0
      const idleMs = t - mouse.lastMove;
      const active = clamp(1 - idleMs / 900, 0, 1);

      // background
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,innerWidth,innerHeight);

      // subtle glow around cursor when active
      if (active > 0.02) {
        const g = ctx.createRadialGradient(mouse.x, mouse.y, 0, mouse.x, mouse.y, 240);
        g.addColorStop(0, "rgba(0,255,255,0.12)");
        g.addColorStop(1, "rgba(0,255,255,0.00)");
        ctx.fillStyle = g;
        ctx.fillRect(0,0,innerWidth,innerHeight);
      }

      const linkDist = 90;

      // particles update & draw
      for (let i=0; i<particles.length; i++){
        const p = particles[i];

        // idle drift
        p.phase += 0.02;
        p.vx += Math.sin(p.phase) * 0.002;
        p.vy += Math.cos(p.phase) * 0.002;

        // attraction when active
        if (active > 0){
          const dx = mouse.x - p.x;
          const dy = mouse.y - p.y;
          const d2 = dx*dx + dy*dy;
          const radius = 280;
          if (d2 < radius*radius){
            const d = Math.sqrt(d2) + 0.0001;
            const pull = (1 - d/radius) * 0.95 * active;
            p.vx += (dx/d) * pull;
            p.vy += (dy/d) * pull;
            // cohesion damping (feel like “凝聚”)
            p.vx *= 0.92;
            p.vy *= 0.92;
          }
        }

        // clamp & move
        p.vx = clamp(p.vx, -1.7, 1.7);
        p.vy = clamp(p.vy, -1.7, 1.7);
        p.x += p.vx;
        p.y += p.vy;

        // wrap
        if (p.x < -30) p.x = innerWidth + 30;
        if (p.x > innerWidth + 30) p.x = -30;
        if (p.y < -30) p.y = innerHeight + 30;
        if (p.y > innerHeight + 30) p.y = -30;

        // links (comic tech web)
        ctx.lineWidth = 1;
        for (let j=i+1; j<particles.length; j++){
          const q = particles[j];
          const dx = q.x - p.x, dy = q.y - p.y;
          const dist = Math.hypot(dx, dy);
          if (dist < linkDist){
            const a = (1 - dist/linkDist) * 0.18;
            ctx.strokeStyle = `rgba(0,255,255,${a})`;
            ctx.beginPath();
            ctx.moveTo(p.x,p.y);
            ctx.lineTo(q.x,q.y);
            ctx.stroke();
          }
        }

        // dot
        ctx.fillStyle = "rgba(0,255,255,0.88)";
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
        ctx.fill();
      }

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    // Expose mouse to other scripts (Three.js)
    window.__CASINA_MOUSE__ = mouse;
  })();
  </script>

  <!-- ===================== -->
  <!-- Three.js 3D Head GLB   -->
  <!-- ===================== -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

    const canvas = document.getElementById('three');

    // renderer
    const renderer = new THREE.WebGLRenderer({
      canvas,
      alpha: true,
      antialias: true
    });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);

    // scene/camera
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      40,
      window.innerWidth / window.innerHeight,
      0.01,
      100
    );
    camera.position.set(0, 0, 3.2);

    // lights (subtle; wireframe material mostly emissive vibe)
    const key = new THREE.PointLight(0x00ffff, 1.4, 50);
    key.position.set(2, 2, 4);
    scene.add(key);

    const fill = new THREE.PointLight(0x00aaff, 0.7, 50);
    fill.position.set(-2, -1, 3);
    scene.add(fill);

    // Group that holds head model
    const headGroup = new THREE.Group();
    scene.add(headGroup);

    // Cyan wireframe material (no textures needed)
    const wireMat = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      wireframe: true,
      transparent: true,
      opacity: 0.85
    });

    // Optional faint solid underlay (helps silhouette)
    const underMat = new THREE.MeshBasicMaterial({
      color: 0x003b3b,
      transparent: true,
      opacity: 0.10
    });

    let headRoot = null;
    let basePos = new THREE.Vector3(0,0,0);

    const loader = new GLTFLoader();

    // Put your GLB at: /head.glb
    loader.load(
      '/head.glb',
      (gltf) => {
        headRoot = gltf.scene;

        // Apply our materials to everything inside
        headRoot.traverse((obj) => {
          if (obj.isMesh) {
            // underlay mesh (clone)
            const under = obj.clone();
            under.material = underMat;
            under.renderOrder = 0;
            headGroup.add(under);

            // wireframe mesh
            obj.material = wireMat;
            obj.renderOrder = 1;
            headGroup.add(obj);

            // improve wireframe visibility
            obj.frustumCulled = false;
            under.frustumCulled = false;
          }
        });

        // Center & scale model nicely
        const box = new THREE.Box3().setFromObject(headGroup);
        const size = new THREE.Vector3();
        const center = new THREE.Vector3();
        box.getSize(size);
        box.getCenter(center);

        // Move model so its center is at origin
        headGroup.position.sub(center);
        basePos.copy(headGroup.position);

        // Scale so it fits view (target height ~1.4 units)
        const target = 1.4;
        const scale = target / Math.max(0.0001, size.y);
        headGroup.scale.setScalar(scale);

        // Slight initial tilt
        headGroup.rotation.set(0, 0, 0);
      },
      undefined,
      (err) => {
        console.error('Failed to load /head.glb', err);
      }
    );

    // Resize handling
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    // Smooth look-at cursor
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const mouse = () => window.__CASINA_MOUSE__ || { x: innerWidth/2, y: innerHeight/2 };

    let ry = 0, rx = 0;
    let bobT = 0;

    function animate() {
      requestAnimationFrame(animate);

      // cursor normalized (-1..1)
      const m = mouse();
      const nx = (m.x / innerWidth) * 2 - 1;
      const ny = (m.y / innerHeight) * 2 - 1;

      // desired rotation (subtle)
      const targetY = clamp(nx * 0.35, -0.35, 0.35);
      const targetX = clamp(-ny * 0.20, -0.25, 0.25);

      // smooth
      ry = ry * 0.90 + targetY * 0.10;
      rx = rx * 0.90 + targetX * 0.10;

      // idle float
      bobT += 0.01;
      const bob = Math.sin(bobT) * 0.03;

      headGroup.rotation.y = ry;
      headGroup.rotation.x = rx;
      headGroup.position.set(basePos.x, basePos.y + bob, basePos.z);

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>