<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CASINA // FACTORY ONLINE</title>

  <style>
    :root{ --cyan: 0,255,255; }
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }

    /* Particle canvas (background) */
    #c {
      position: fixed; inset: 0;
      width: 100vw; height: 100vh;
      display:block;
      z-index: 0;
    }

    /* 3D canvas (head) */
    #three {
      position: fixed; inset: 0;
      width: 100vw; height: 100vh;
      display:block;
      z-index: 1;
      pointer-events: none;
    }

    /* HUD text */
    .hud{
      position: fixed; left: 18px; top: 16px;
      color: rgba(var(--cyan),0.85);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      letter-spacing: .12em;
      text-transform: uppercase;
      user-select: none;
      pointer-events: none;
      mix-blend-mode: screen;
      z-index: 2;
    }
    .hud .title{ font-size: 14px; opacity: 0.95; }
    .hud .sub{ margin-top: 6px; font-size: 11px; opacity: 0.6; }

    /* Optional: vignette */
    .vignette{
      position: fixed; inset: 0;
      pointer-events: none;
      z-index: 2;
      background: radial-gradient(circle at 50% 55%, rgba(0,0,0,0) 0%, rgba(0,0,0,0.35) 60%, rgba(0,0,0,0.7) 100%);
      mix-blend-mode: multiply;
    }
  </style>
</head>

<body>
  <!-- Background particles -->
  <canvas id="c"></canvas>

  <!-- 3D head overlay -->
  <canvas id="three"></canvas>

  <div class="hud" aria-hidden="true">
    <div class="title">XERLEVATE // FACTORY ONLINE</div>
    <div class="sub">cyan field · idle drift / cursor cohesion</div>
  </div>
  <div class="vignette" aria-hidden="true"></div>

  <!-- ===================== -->
  <!-- Particles (your code) -->
  <!-- ===================== -->
  <script>
  (() => {
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha: false });

    // -------- Retina-safe resize --------
    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width  = Math.floor(innerWidth  * dpr);
      canvas.height = Math.floor(innerHeight * dpr);
      canvas.style.width = innerWidth + "px";
      canvas.style.height = innerHeight + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    addEventListener("resize", resize);
    resize();

    // -------- Mouse state --------
    const mouse = { x: innerWidth/2, y: innerHeight/2, lastMove: 0 };
    const now = () => performance.now();

    function touchMouse(x,y){
      mouse.x = x; mouse.y = y;
      mouse.lastMove = now();
    }
    addEventListener("pointermove", (e)=> touchMouse(e.clientX, e.clientY));
    addEventListener("pointerdown", (e)=> touchMouse(e.clientX, e.clientY));

    // -------- Particles --------
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const rand = (a,b)=>a+Math.random()*(b-a);

    let COUNT = 220;
    function recomputeCount(){
      COUNT = Math.min(260, Math.max(120, Math.floor((innerWidth*innerHeight)/6500)));
    }
    recomputeCount();
    addEventListener("resize", recomputeCount);

    const particles = [];
    function seed() {
      particles.length = 0;
      for (let i=0; i<COUNT; i++) {
        particles.push({
          x: rand(0, innerWidth),
          y: rand(0, innerHeight),
          vx: rand(-0.35, 0.35),
          vy: rand(-0.35, 0.35),
          r: rand(1.2, 2.6),
          phase: rand(0, Math.PI*2),
        });
      }
    }
    seed();

    // -------- Render loop --------
    function frame(t){
      // activity strength: move -> 1, idle -> 0
      const idleMs = t - mouse.lastMove;
      const active = clamp(1 - idleMs / 900, 0, 1);

      // background
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,innerWidth,innerHeight);

      // subtle glow around cursor when active
      if (active > 0.02) {
        const g = ctx.createRadialGradient(mouse.x, mouse.y, 0, mouse.x, mouse.y, 240);
        g.addColorStop(0, "rgba(0,255,255,0.12)");
        g.addColorStop(1, "rgba(0,255,255,0.00)");
        ctx.fillStyle = g;
        ctx.fillRect(0,0,innerWidth,innerHeight);
      }

      const linkDist = 90;

      // particles update & draw
      for (let i=0; i<particles.length; i++){
        const p = particles[i];

        // idle drift
        p.phase += 0.02;
        p.vx += Math.sin(p.phase) * 0.002;
        p.vy += Math.cos(p.phase) * 0.002;

        // attraction when active
        if (active > 0){
          const dx = mouse.x - p.x;
          const dy = mouse.y - p.y;
          const d2 = dx*dx + dy*dy;
          const radius = 280;
          if (d2 < radius*radius){
            const d = Math.sqrt(d2) + 0.0001;
            const pull = (1 - d/radius) * 0.95 * active;
            p.vx += (dx/d) * pull;
            p.vy += (dy/d) * pull;
            // cohesion damping (feel like “凝聚”)
            p.vx *= 0.92;
            p.vy *= 0.92;
          }
        }

        // clamp & move
        p.vx = clamp(p.vx, -1.7, 1.7);
        p.vy = clamp(p.vy, -1.7, 1.7);
        p.x += p.vx;
        p.y += p.vy;

        // wrap
        if (p.x < -30) p.x = innerWidth + 30;
        if (p.x > innerWidth + 30) p.x = -30;
        if (p.y < -30) p.y = innerHeight + 30;
        if (p.y > innerHeight + 30) p.y = -30;

        // links
        ctx.lineWidth = 1;
        for (let j=i+1; j<particles.length; j++){
          const q = particles[j];
          const dx = q.x - p.x, dy = q.y - p.y;
          const dist = Math.hypot(dx, dy);
          if (dist < linkDist){
            const a = (1 - dist/linkDist) * 0.18;
            ctx.strokeStyle = `rgba(0,255,255,${a})`;
            ctx.beginPath();
            ctx.moveTo(p.x,p.y);
            ctx.lineTo(q.x,q.y);
            ctx.stroke();
          }
        }

        // dot
        ctx.fillStyle = "rgba(0,255,255,0.88)";
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
        ctx.fill();
      }

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    // Expose mouse to other scripts (Three.js)
    window.__CASINA_MOUSE__ = mouse;
  })();
  </script>

  <!-- ===================== -->
  <!-- Three.js (UMD, no module) -->
  <!-- ===================== -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
  (function () {
    const canvas = document.getElementById('three');
    if (!canvas) {
      console.error('[THREE] canvas#three not found');
      return;
    }

    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
    camera.position.set(0, 0.6, 3.2);
    camera.lookAt(0, 0.4, 0);

    // DEBUG helpers (you SHOULD see these)
    scene.add(new THREE.AxesHelper(0.8));
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(0.25, 0.25, 0.25),
      new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true })
    );
    cube.position.set(0, 0.35, 0);
    scene.add(cube);

    const headGroup = new THREE.Group();
    scene.add(headGroup);

    // Load GLB
    const loader = new THREE.GLTFLoader();
    loader.load(
      '/head.glb',
      (gltf) => {
        console.log('[THREE] GLB loaded', gltf);
        const obj = gltf.scene;
        headGroup.add(obj);

        // Force visible wireframe
        obj.traverse((m) => {
          if (m.isMesh) {
            m.material = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
            m.frustumCulled = false;
          }
        });

        // Auto-fit to camera
        const box = new THREE.Box3().setFromObject(headGroup);
        const size = new THREE.Vector3();
        const center = new THREE.Vector3();
        box.getSize(size);
        box.getCenter(center);
        headGroup.position.sub(center);

        const target = 1.3; // target height in world units
        const scale = target / Math.max(0.0001, size.y);
        headGroup.scale.setScalar(scale);
        headGroup.position.y += 0.35;

        console.log('[THREE] fit size:', size, 'scale:', scale);
      },
      undefined,
      (err) => console.error('[THREE] GLB load failed', err)
    );

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function getMouse() { return window.__CASINA_MOUSE__ || { x: innerWidth / 2, y: innerHeight / 2 }; }

    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    let t = 0;
    function animate() {
      requestAnimationFrame(animate);
      t += 0.01;

      const m = getMouse();
      const nx = (m.x / innerWidth) * 2 - 1;
      const ny = (m.y / innerHeight) * 2 - 1;

      headGroup.rotation.y = clamp(nx * 0.35, -0.35, 0.35);
      headGroup.rotation.x = clamp(-ny * 0.2, -0.25, 0.25);
      headGroup.position.y = 0.35 + Math.sin(t) * 0.03;

      cube.rotation.y += 0.01;

      renderer.render(scene, camera);
    }

    console.log('[THREE] boot ok');
    animate();
  })();
  </script>
</body>
</html>