<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CASINA</title>

<style>
  html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#000; font-family:monospace; }

  /* layer stack */
  #particlesCanvas{
    position:fixed; inset:0;
    width:100vw; height:100vh;
    z-index:0;
  }
  canvas.threeCanvas{
    position:fixed; inset:0;
    width:100vw; height:100vh;
    z-index:1;
    pointer-events:none; /* so mouse still hits particle layer */
  }

  #hud{
    position:fixed;
    top:20px; left:20px;
    color:cyan; opacity:.7;
    letter-spacing:2px;
    z-index:2;
    user-select:none;
    pointer-events:none;
  }
</style>

<!-- modern three.js -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>

<body>
<canvas id="particlesCanvas"></canvas>

<div id="hud">CASINA // FACTORY ONLINE<br><span style="opacity:.6">cyan field · idle drift / cursor cohesion</span></div>

<script type="module">
import * as THREE from "three";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

/* ===== HOLO OVERLAY HELPER ===== */
function addHoloOverlay(root, options = {}) {
  const color = options.color ?? 0x00ffff;
  const wireOpacity = options.wireOpacity ?? 0.22;
  const edgeOpacity = options.edgeOpacity ?? 0.55;

  const meshes = [];
  root.traverse((obj) => {
    if (!obj.isMesh || !obj.geometry) return;
    if (obj.userData.__isHoloPart) return;
    meshes.push(obj);
  });

  for (const obj of meshes) {
    const wireMat = new THREE.MeshBasicMaterial({
      color,
      wireframe: true,
      transparent: true,
      opacity: wireOpacity,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      depthTest: true,
      polygonOffset: true,
      polygonOffsetFactor: -1,
      polygonOffsetUnits: -1
    });

    const wire = new THREE.Mesh(obj.geometry, wireMat);
    wire.userData.__isHoloPart = true;
    wire.renderOrder = 2;

    const edgesGeo = new THREE.EdgesGeometry(obj.geometry, 28);
    const edgesMat = new THREE.LineBasicMaterial({
      color,
      transparent: true,
      opacity: edgeOpacity * (0.8 + Math.random()*0.2),
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    const edges = new THREE.LineSegments(edgesGeo, edgesMat);
    edges.userData.__isHoloPart = true;
    edges.renderOrder = 3;

    obj.add(wire);
    obj.add(edges);
  }
}
/* ===== END HOLO OVERLAY HELPER ===== */


/* =========================
   Particle Background (2D)
========================= */
const pCanvas = document.getElementById("particlesCanvas");
const pCtx = pCanvas.getContext("2d");

let W = 0, H = 0, DPR = 1;

// responsive params
let N = 140;
let linkDist = 150;
let mouseRadius = 260;
let glowRadius = 160;
let pointRadius = 1.9;

let particles = [];

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }

function recomputeParticleParams(){
  const base = Math.min(W, H);

  // density-based N (area scaled) + clamp for perf
  // tweak density if you want: smaller denom => denser
  const density = 1 / 5000; // ~1 particle per 5000 px
  N = clamp(Math.round(W * H * density), 90, 240);

  // link distance scales with short edge
  linkDist = clamp(base * 0.18, 110, 220);

  // mouse influence scales with short edge
  mouseRadius = clamp(base * 0.32, 220, 420);

  // glow radius scales too
  glowRadius = clamp(base * 0.20, 140, 260);

  // point radius mild scaling (don’t overdo)
  pointRadius = clamp(base * 0.0022, 1.5, 2.3);
}

function rebuildParticles(keepMomentum=false){
  const prev = particles;
  particles = Array.from({length:N}, (_,i)=> {
    const p = {
      x: Math.random()*W,
      y: Math.random()*H,
      vx: (Math.random()*2-1)*0.25,
      vy: (Math.random()*2-1)*0.25
    };
    if (keepMomentum && prev && prev[i]){
      p.vx = prev[i].vx;
      p.vy = prev[i].vy;
    }
    return p;
  });
}

function resize2D(){
  DPR = Math.min(2, window.devicePixelRatio || 1);
  W = Math.floor(window.innerWidth);
  H = Math.floor(window.innerHeight);

  pCanvas.width = Math.floor(W * DPR);
  pCanvas.height = Math.floor(H * DPR);
  pCanvas.style.width = W + "px";
  pCanvas.style.height = H + "px";
  pCtx.setTransform(DPR,0,0,DPR,0,0);

  recomputeParticleParams();
  rebuildParticles(false);
}
resize2D();

const mouse = { x: W/2, y: H/2, tx: W/2, ty: H/2, active:false };
let lastMouseMove = performance.now();
let mouseStrength = 0;

window.addEventListener("mousemove",(e)=>{
  mouse.tx = e.clientX; mouse.ty = e.clientY;
  mouse.active = true;
  lastMouseMove = performance.now();
});
window.addEventListener("mouseleave",()=>{ mouse.active = false; });

function tickParticles(){
  mouse.x = lerp(mouse.x, mouse.tx, 0.18);
  mouse.y = lerp(mouse.y, mouse.ty, 0.18);

  const now = performance.now();
  const idle = Math.max(0, (now - lastMouseMove - 120) / 600);
  const targetStrength = mouse.active ? (1 - Math.min(1, idle)) : 0;
  mouseStrength = lerp(mouseStrength, targetStrength, 0.08);

  pCtx.clearRect(0,0,W,H);
  pCtx.fillStyle = "rgba(0,0,0,0.55)";
  pCtx.fillRect(0,0,W,H);

  // mouse glow (responsive)
  if (mouse.active){
    const g = pCtx.createRadialGradient(mouse.x, mouse.y, 0, mouse.x, mouse.y, glowRadius);
    g.addColorStop(0, "rgba(0,255,255,0.18)");
    g.addColorStop(0.35, "rgba(0,255,255,0.06)");
    g.addColorStop(1, "rgba(0,255,255,0)");
    pCtx.fillStyle = g;
    const pad = glowRadius + 60;
    pCtx.fillRect(mouse.x-pad, mouse.y-pad, pad*2, pad*2);
  }

  for (const p of particles){
    // idle drift
    p.vx += (Math.random()*2-1) * 0.02;
    p.vy += (Math.random()*2-1) * 0.02;

    const dx = mouse.x - p.x;
    const dy = mouse.y - p.y;
    const dist = Math.hypot(dx,dy);

    if (mouse.active && dist < mouseRadius){
      const falloff = 1 - dist/mouseRadius;

      const pull = falloff * falloff * 0.040 * mouseStrength;
      p.vx += dx * pull;
      p.vy += dy * pull;

      const release = falloff * falloff * 0.010 * (1 - mouseStrength);
      if (dist > 1e-3){
        p.vx += (-dx / dist) * release;
        p.vy += (-dy / dist) * release;
      }
    }

    p.x += p.vx;
    p.y += p.vy;

    if (p.x < -20) p.x = W+20;
    if (p.x > W+20) p.x = -20;
    if (p.y < -20) p.y = H+20;
    if (p.y > H+20) p.y = -20;

    p.vx *= 0.994;
    p.vy *= 0.994;

    const sp = Math.hypot(p.vx,p.vy);
    const maxSp = 1.8;
    if (sp > maxSp){
      p.vx *= maxSp/sp;
      p.vy *= maxSp/sp;
    }
  }

  // links (responsive linkDist)
  pCtx.lineWidth = 1;
  for (let i=0;i<N;i++){
    for (let j=i+1;j<N;j++){
      const a = particles[i], b = particles[j];
      const dx = a.x-b.x, dy=a.y-b.y;
      const d = Math.hypot(dx,dy);
      if (d < linkDist){
        const alpha = (1 - d/linkDist) * 0.45;
        pCtx.strokeStyle = `rgba(0,255,255,${alpha})`;
        pCtx.beginPath();
        pCtx.moveTo(a.x,a.y);
        pCtx.lineTo(b.x,b.y);
        pCtx.stroke();
      }
    }
  }

  // points (responsive radius)
  for (const p of particles){
    pCtx.fillStyle = "rgba(0,255,255,0.9)";
    pCtx.beginPath();
    pCtx.arc(p.x,p.y,pointRadius,0,Math.PI*2);
    pCtx.fill();
  }

  requestAnimationFrame(tickParticles);
}
tickParticles();


/* =========================
   Three.js Layer (3D)
========================= */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0, 0, 2.4);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
renderer.domElement.className = "threeCanvas";
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.9));
const key = new THREE.DirectionalLight(0xffffff, 1.2);
key.position.set(2,2,4);
scene.add(key);

let head = null;

const loader = new GLTFLoader();
loader.load("/head.glb", (gltf)=>{
  head = gltf.scene;

  head.position.set(0, 0, 0);
  head.scale.set(2.6, 2.6, 2.6);

  head.traverse((o)=>{
    if (!o.isMesh) return;
    if (o.material){
      o.material = o.material.clone();
      o.material.transparent = true;
      o.material.opacity = 0;
      o.material.depthWrite = false;
    }
  });

  addHoloOverlay(head, {
    color: 0x00ffff,
    wireOpacity: 0.18,
    edgeOpacity: 0.55
  });

  scene.add(head);
  console.log("GLB LOADED + HOLO");
}, undefined, (err)=>{
  console.error("GLB load error", err);
});

const m3 = { x:0, y:0 };
window.addEventListener("mousemove",(e)=>{
  m3.x = (e.clientX / window.innerWidth) * 2 - 1;
  m3.y = (e.clientY / window.innerHeight) * 2 - 1;
});

window.addEventListener("resize", ()=>{
  resize2D();

  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

let t = 0;
function animate(){
  requestAnimationFrame(animate);
  t += 0.016;

  if (head){
    head.position.y =
      Math.sin(t*0.9)*0.07 +
      Math.sin(t*0.35)*0.02;

    const targetY = m3.x * 0.45;
    const targetX = m3.y * 0.25;
    head.rotation.y = lerp(head.rotation.y, targetY, 0.08);
    head.rotation.x = lerp(head.rotation.x, targetX, 0.08);
  }

  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>