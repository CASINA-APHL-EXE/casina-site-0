<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CASINA</title>

<style>
  html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#000; font-family:monospace; }

  /* layer stack */
  #particlesCanvas{
    position:fixed; inset:0;
    width:100vw; height:100vh;
    z-index:0;
  }
  canvas.threeCanvas{
    position:fixed; inset:0;
    width:100vw; height:100vh;
    z-index:1;
    pointer-events:none; /* so mouse still hits particle layer */
  }

  #hud{
    position:fixed;
    top:20px; left:20px;
    color:cyan; opacity:.7;
    letter-spacing:2px;
    z-index:2;
    user-select:none;
    pointer-events:none;
  }
</style>

<!-- modern three.js -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>

<body>
<canvas id="particlesCanvas"></canvas>

<div id="hud">CASINA // FACTORY ONLINE<br><span style="opacity:.6">cyan field · idle drift / cursor cohesion</span></div>

<script type="module">
import * as THREE from "three";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

/* ===== HOLO OVERLAY HELPER (PASTE HERE) ===== */
function addHoloOverlay(root, options = {}) {
  const color = options.color ?? 0x00ffff;
  const wireOpacity = options.wireOpacity ?? 0.22;
  const edgeOpacity = options.edgeOpacity ?? 0.55;

  // ① 先收集“原始 mesh”（避免边遍历边 add）
  const meshes = [];
  root.traverse((obj) => {
    if (!obj.isMesh || !obj.geometry) return;
    if (obj.userData.__isHoloPart) return; // 防止重复
    meshes.push(obj);
  });

  // ② 再统一加 overlay
  for (const obj of meshes) {
    const wireMat = new THREE.MeshBasicMaterial({
      color,
      wireframe: true,
      transparent: true,
      opacity: wireOpacity,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      depthTest: true,
      polygonOffset: true,
      polygonOffsetFactor: -1,
      polygonOffsetUnits: -1
    });

    const wire = new THREE.Mesh(obj.geometry, wireMat);
    wire.userData.__isHoloPart = true;
    wire.renderOrder = 2;

    const edgesGeo = new THREE.EdgesGeometry(obj.geometry, 28);
    const edgesMat = new THREE.LineBasicMaterial({
      color,
      transparent: true,
      opacity: edgeOpacity * (0.8 + Math.random()*0.2),
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    const edges = new THREE.LineSegments(edgesGeo, edgesMat);
    edges.userData.__isHoloPart = true;
    edges.renderOrder = 3;

    obj.add(wire);
    obj.add(edges);
  }
}
/* ===== END HOLO OVERLAY HELPER ===== */

/* =========================
   Particle Background (2D)
========================= */
const pCanvas = document.getElementById("particlesCanvas");
const pCtx = pCanvas.getContext("2d");

let W = 0, H = 0, DPR = 1;
function resize2D(){
  DPR = Math.min(2, window.devicePixelRatio || 1);
  W = Math.floor(window.innerWidth);
  H = Math.floor(window.innerHeight);
  pCanvas.width = Math.floor(W * DPR);
  pCanvas.height = Math.floor(H * DPR);
  pCanvas.style.width = W + "px";
  pCanvas.style.height = H + "px";
  pCtx.setTransform(DPR,0,0,DPR,0,0);
}
resize2D();

const mouse = { x: W/2, y: H/2, tx: W/2, ty: H/2, active:false };
let lastMouseMove = performance.now();
let mouseStrength = 0; // 0..1, smooth strength

window.addEventListener("mousemove",(e)=>{
  mouse.tx = e.clientX; mouse.ty = e.clientY;
  mouse.active = true;
  lastMouseMove = performance.now();
});
window.addEventListener("mouseleave",()=>{ mouse.active = false; });

function lerp(a,b,t){ return a + (b-a)*t; }

const N = 140;
const particles = Array.from({length:N},()=>({
  x: Math.random()*W,
  y: Math.random()*H,
  vx: (Math.random()*2-1)*0.25,
  vy: (Math.random()*2-1)*0.25
}));

function tickParticles(){
  // smooth mouse
  mouse.x = lerp(mouse.x, mouse.tx, 0.18);
  mouse.y = lerp(mouse.y, mouse.ty, 0.18);
    // mouse strength: if idle, strength fades out
  const now = performance.now();
  const idle = Math.max(0, (now - lastMouseMove - 120) / 600); // 0 after 120ms, ramps to 1 over ~600ms
  const targetStrength = mouse.active ? (1 - Math.min(1, idle)) : 0;
  mouseStrength = lerp(mouseStrength, targetStrength, 0.08);

  // clear (less smear, keep crisp)
  pCtx.clearRect(0,0,W,H);
  pCtx.fillStyle = "rgba(0,0,0,0.55)";
  pCtx.fillRect(0,0,W,H);

  // --- mouse glow ---
  if (mouse.active){
    const g = pCtx.createRadialGradient(mouse.x, mouse.y, 0, mouse.x, mouse.y, 160);
    g.addColorStop(0, "rgba(0,255,255,0.18)");
    g.addColorStop(0.35, "rgba(0,255,255,0.06)");
    g.addColorStop(1, "rgba(0,255,255,0)");
    pCtx.fillStyle = g;
    pCtx.fillRect(mouse.x-200, mouse.y-200, 400, 400);
  }

  // update particles
  for (const p of particles){

    // --- idle drift (permanent life) ---
    // tiny noise-like acceleration so it always moves
    p.vx += (Math.random()*2-1) * 0.02;
    p.vy += (Math.random()*2-1) * 0.02;

    // --- cursor cohesion ---
    const dx = mouse.x - p.x;
    const dy = mouse.y - p.y;
    const dist = Math.hypot(dx,dy);

    if (mouse.active && dist < 260){
        const falloff = 1 - dist/260;

        // attraction fades when mouse is idle
        const pull = falloff * falloff * 0.040 * mouseStrength;
        p.vx += dx * pull;
        p.vy += dy * pull;

        // when mouse stops (mouseStrength low), gently push outward to "release" the cluster
        const release = falloff * falloff * 0.010 * (1 - mouseStrength);
        if (dist > 1e-3){
            p.vx += (-dx / dist) * release;
            p.vy += (-dy / dist) * release;
        }
    }

    // integrate
    p.x += p.vx;
    p.y += p.vy;

    // wrap
    if (p.x < -20) p.x = W+20;
    if (p.x > W+20) p.x = -20;
    if (p.y < -20) p.y = H+20;
    if (p.y > H+20) p.y = -20;

    // damping (less damping so it doesn't "die")
    p.vx *= 0.994;
    p.vy *= 0.994;

    // cap speed
    const sp = Math.hypot(p.vx,p.vy);
    const maxSp = 1.8;
    if (sp > maxSp){
      p.vx *= maxSp/sp;
      p.vy *= maxSp/sp;
    }
  }

  // draw links (a bit brighter + longer range)
  pCtx.lineWidth = 1;
  for (let i=0;i<N;i++){
    for (let j=i+1;j<N;j++){
      const a = particles[i], b = particles[j];
      const dx = a.x-b.x, dy=a.y-b.y;
      const d = Math.hypot(dx,dy);
      if (d < 150){
        const alpha = (1 - d/150) * 0.45;
        pCtx.strokeStyle = `rgba(0,255,255,${alpha})`;
        pCtx.beginPath();
        pCtx.moveTo(a.x,a.y);
        pCtx.lineTo(b.x,b.y);
        pCtx.stroke();
      }
    }
  }

  // draw points (slightly bigger, punchier)
  for (const p of particles){
    pCtx.fillStyle = "rgba(0,255,255,0.9)";
    pCtx.beginPath();
    pCtx.arc(p.x,p.y,1.9,0,Math.PI*2);
    pCtx.fill();
  }

  requestAnimationFrame(tickParticles);
}
tickParticles();

/* =========================
   Three.js Layer (3D)
========================= */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0, 0, 2.4);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
renderer.domElement.className = "threeCanvas";
document.body.appendChild(renderer.domElement);

// lighting (neutral now; later we do cyan holo)
scene.add(new THREE.AmbientLight(0xffffff, 0.9));
const key = new THREE.DirectionalLight(0xffffff, 1.2);
key.position.set(2,2,4);
scene.add(key);

let head = null;

// load GLB
const loader = new GLTFLoader();
loader.load("/head.glb", (gltf)=>{
  head = gltf.scene;

  // ✅ 更居中：从 -0.15 改到 -0.02
  head.position.set(0, 0, 0);
  head.scale.set(2.6, 2.6, 2.6);

  // 可选：让原模型暗一点，线框更突出
  head.traverse((o)=>{
  if (!o.isMesh) return;

  // 隐藏实体模型
  if (o.material){
    o.material = o.material.clone();
    o.material.transparent = true;
    o.material.opacity = 0;
    o.material.depthWrite = false;
  }
});
  

  // ✅ 加 holo 线框叠层（关键）
  addHoloOverlay(head, {
    color: 0x00ffff,
    wireOpacity: 0.18,
    edgeOpacity: 0.55
  });

  scene.add(head);

  console.log("GLB LOADED + HOLO");
}, undefined, (err)=>{
  console.error("GLB load error", err);
});

/* mouse -> head follow */
const m3 = { x:0, y:0 };
window.addEventListener("mousemove",(e)=>{
  m3.x = (e.clientX / window.innerWidth) * 2 - 1;     // -1..1
  m3.y = (e.clientY / window.innerHeight) * 2 - 1;    // -1..1
});

/* resize */
window.addEventListener("resize", ()=>{
  resize2D();
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* render loop */
let t = 0;
function animate(){
  requestAnimationFrame(animate);
  t += 0.016;

  // subtle float
  if (head){
    head.position.y = 0 + Math.sin(t*0.9)*0.07;

    // cursor tracking rotation
    const targetY = m3.x * 0.45;
    const targetX = m3.y * 0.25;
    head.rotation.y = lerp(head.rotation.y, targetY, 0.08);
    head.rotation.x = lerp(head.rotation.x, targetX, 0.08);
  }

  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>